# 分布式ID

分布式ID生成算法

* 需求全网唯一，阿里云、聚石塔、多多云、云鼎都可使用
* 分布式，多容器同时生成
* 可排序长整型兼容JS

## Twitter 雪花算法 Snowflake

twiter 的做法应该是每个数据中心(最多32个数据中心)都有ID生成服务，每个ID生成服务都是多实例的(最多32个实例)，各服务向ID生成服务请求ID，如此做到ID全球唯一

## 数据结构

为了兼容JS，Long长整数使用 53 位，分成3部分

* 25 位：时间戳(距离2021-07-01的秒数，可用25.5年，可修改成26位51年)，雪花算法41位，毫秒时间戳
* 21 位：序号(2,097,152)，雪花算法12位
* 7 位：服务器标识(128)，雪花算法10位
	* 3位：数据中心ID，8个，雪花算法5位(目前有4个数据中心，阿里云、聚石塔、多多云、云鼎)
	* 4位：实例ID，16个，雪花算法5位
## 方案1

SDK方案，各应用使用ID生成SDK，SDK通过分发服务获取服务器标识，然后生成ID。

### 算法

* 首次获取ID需要设置服务器标识，如果不能远程获取可从环境变量中获取，环境变量里也没有则随机生成
* 获取ID时设置时间戳为当前时间距离2021-07-01的秒数，序号持续累计，不随时间变化而归零
* 序号超过最大值(2,097,152)时，可延时跨越当前秒数再归零继续（防止归零后顺序错乱）

### 关于服务器标识

* 提供服务器标识的分发服务
* 不同的应用(或者表)使用不同的服务器标识队列
* ID算法启动前需要向分发服务，申请服务器标识(1-128)
* 之后每隔1小时通知分发服务，该服务器标识正被占用分发服务超过1小时没有收到占用
* 通知，则将服务器标识回收待用通知分发服务时需要提供应用服务器名称IP地址等信息，如果应用相同，服务器名称和IP地址不同，但占用相同服务器标识，分发服务要进行干涉，调整服务器标识，防止重复
* 头8个服务器标识可以保留，给开发和测试团队使用

### 注意

* 分布式ID生成需要依赖网络，连接不到分发服务就需要手工/随机指定服务器标识，这就有ID重复的可能
* 除非1小时内重启120次(30秒重启一次)，否则在线分发的服务器标识够用
* 通知分发服务时间要小于1小时，防止错误
* 刚回收的服务器标识放到队列末尾，尽量延后使用
* 相同服务器，1秒创建ID超过2百万个，ID生成会发生卡顿
* 最简单的ID生成算法空操作，在开发机器测试，生成1百万个ID需要1.1秒
* 连续生成2百万个ID，会发生一次卡顿，如果不是强顺序ID，可以避免这个卡顿，跨秒生成2百万个自动归零，不等待跨秒

### ID重复的可能

* 当前算法运行一段时间生成过ID
* 停止算法，间隔1小时，等待服务器标识回收
* 调整时间回到过去，上次启动算法之前
* 不断尝试获取服务器标识，让服务器标识碰巧和之前使用的服务器标识一致，连续重启120次
* 再启动算法，保证当前时间与上次启动时间秒数的完全相同，则可生成重复ID

## 方案2

ID生成服务方案，各应用向ID生成服务请求ID，ID生成服务，根据请求数量批量生成ID返回。

### ID生成服务

* ID生成服务配置好数据中心ID，每个实例都使用不同的服务ID
* 服务使用redis来分发服务ID，确保同一个服务ID被一个实例占用
* 不用区分应用，所有请求都使用一套不重复的ID
* 同一个实例可以占用多个实例ID
* 创建ID超过2百万，序号归零，实例ID更换，可避免卡顿
* 客户端使用的时候可以一次获取一批ID，快使用完再批量获取
* 批量获取的结果是序号起始、截止，并不传送所有ID

* 为什么不直接使用雪花算法

* 雪花算法生成的ID转换成JS数值，会发生末位被设置成0的错误(JS控制台执行: 2**53==2**53+1)
* 雪花算法严重依赖系统时间，如果服务器时间变化(服务器时间自动向前校准)，ID就必然重复，需要进行异常处理
* 当前算法在服务器校准时间会改变时间戳，但序号还在连续生成，不容易重复

## 场景

* 可以在所有使用数据库自增主键的位置使用
* 方便数据库合并、拆分
* 数据关联不需要使用复合主键
* key/value数据库作为key不担心重复
* 不依赖数据库序列，没有锁的风险
* 长整数操作速度快
* 占用索引小
* 兼容JS
* 生成速度快，百万/秒
* 不易重复
* 理论每秒可最多生成2.6亿个ID

## 缺点

* 需要依赖服务（服务器标识分发或ID生成服务）
* 需要外部资源redis

## 讨论问题

* 是否使用这个算法
* 数据结构，年限问题
* 方案的选择
